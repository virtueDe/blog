### promise实现原理，如何中止

* 一个promise的当前状态只能是pending、fulfilled和rejected三种之一。状态改变只能是pending到fulfilled或者pending到rejected。状态改变不可逆。
* promise的then方法接收两个可选参数，表示该promise状态改变时的回调(promise.then(onFulfilled, onRejected))。then方法返回一个promise。then 方法可以被同一个 promise 调用多次。
*
* 中止：
  * 1.当Promise链中抛出一个错误时，错误信息沿着链路向后传递，直至被捕获。利用这个特性能跳过链中函数的调用，直至链路终点，变相地结束Promise链。
  * 2. 若onFulfilled或onRejected是一个函数，当函数返回一个新Promise对象时，原Promise对象的状态将跟新对象保持一致，详见Promises/A+标准。 因此，当新对象保持“pending”状态时，原Promise链将会中止执行。
* 参考：[30分钟，让你彻底明白Promise原理](https://segmentfault.com/a/1190000009478377?utm_source=tag-newest)
* 参考：[中断或取消Promise链的可行方案](https://blog.csdn.net/ambit_tsai/article/details/80635594)

### 什么是协商缓存

* 浏览器缓存包含两种类型，即强缓存（也叫本地缓存）和协商缓存
* 缓存的优点：
  * 减少冗余的数据传输
  * 减少服务器负担
  * 加快客户端加载网页的速度
* 协商缓存 （304缓存）
  * 协商缓存每次请求都会与服务器交互，第一次是拿数据和标识的过程，第二次开始，就是浏览器询问服务器资源是否有更新的过程。每次请求都会传输数据，如果命中缓存，则资源的 Status 状态码为 304 而不是 200 。
* 参考: [10分钟彻底搞懂Http的强制缓存和协商缓存](https://segmentfault.com/a/1190000016199807)
  
### 常见的排序算法，如何实现

* 冒泡，插入，选择，快排，归并。。。

### 闭包的特点，导致内存泄漏有什么办法释放，为什么别的语言没有闭包

* 变量作用域
  * 变量的作用域无非就两种：全局变量和局部变量。
  * js语言的特别之处就在于：函数内部可以直接读取全局变量，但是在函数外部无法读取函数内部的局部变量。
  * 注意点：在函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明的是一个全局变量！
* 闭包是将函数内部和函数外部连接起来的桥梁。

* 闭包概念:
　* 闭包就是有权访问另一个函数作用域中变量的函数.
  * 闭包是定义在函数中的函数.
　　*闭包能访问包含函数的变量.
　　* 即使包含函数执行完了, 被闭包引用的变量也得不到释放.
* 缺点：由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
  
### 树的深度遍历和广度遍历如何实现

* 广度优先遍历
  * BFS即Breadth First Search，其过程检验来说是对每一层节点依次访问，访问完一层进入下一层，而且每个节点只能访问一次。
  * 需要用到队列（Queue）来存储节点对象，队列的特点就是先进先出。
* 深度优先遍历
  * DFS即Depth First Search，其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。
  * 深度优先遍历各个节点，需要使用到栈（Stack）这种数据结构。stack的特点是是先进后出。
  
### 轮播是怎么实现的，几十万图片轮播如何实现

* 一系列的大小相等的图片平铺，利用CSS布局只显示一张图片，其余隐藏。通过计算偏移量利用定时器实现自动播放，或通过手动点击事件切换图片。
* 无缝轮播：
* 海量图片轮播：？？
  
### canvas如何实现点击事件

* Canvas是一个整体，传统的DOM的事件处理机制在Canvas里并不适应。
* 因为绑定事件只能给canvas本身绑定，所以在判断是那个组件触发click要根据鼠标的坐标来判断。

```javascript
canvas.addEventListener('click', function(event) {
     // 1. 从event中获取当前点击的坐标x,y
     // 2. 判断x,y是否在canvas中某个图片或元素的坐标区域内
}, false)
```

### 浏览器没有bind函数，要如何给浏览器添加bind方法

* 一个函数通过调用bind()方法创建一个新的绑定函数，调用新绑定函数，会在指定的作用域中传入参数并执行。使用bind()方法函数创建一个新绑定函数，它包装了原函数对象，调用绑定函数通常会导致执行包装函数。
* 高版本的firefox,chrome及ie10以上的浏览器实现了Function.prototype.bind方法
* bind方法调用语法为：`functionObj.bind(thisArg[, arg1[, arg2[, ...]]])`
* 使用范例参考如下:

```javascript
    function move(x, y) {
        this.x += x;
        this.y += y;
    }
    var point = {x:1, y:2};
    var pointmove = move.bind(point, 2, 2);
    pointmove(); // {x:3, y:4}
```

### 什么是高阶函数，特点

* 高阶函数：JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。
* 简述：让函数的参数能够接收别的函数。
* 常用的高阶函数：
  * map(): 将调用的数组的每个元素传递给指定的函数,并返回一个数组,它包含该函数的返回值。
  * reduce(): Array的reduce()把一个函数作用在这个Array的[x1, x2, x3...]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算
  * filter(): 把Array的某些元素过滤掉，然后返回剩下的元素。
  * sort(): 默认将Array的所有元素转为String排序，支持接收一个自定义比较函数的参数

### 如何实现一个深拷贝函数

* 深拷贝(deepClone)
  * 对于一个引用类型，如果直接将它赋值给另一个变量，由于这两个引用指向同一个地址，这时改变其中任何一个引用，另一个都会受到影响。当我们想复制一个对象并且切断与这个对象的联系，就要使用深拷贝。对于一个对象来说，由于可能有多层结构，所以我们可以使用递归或树的广度优先遍历来实现。
* 深拷贝对象还有另一个解决方法，在对象中不含有函数的时候，使用JSON解析反序列化就可以得到一个深拷贝对象
* 参考：[js实现深拷贝](https://www.cnblogs.com/rusr/p/8984604.html)

### 如何实现一个节流和防抖函数，有什么区别

* 节流：节流函数允许一个函数在规定的时间内只执行一次。
* 防抖：它的做法是限制下次函数调用之前必须等待的时间间隔。正确实现 debouncing 的方法是将若干个函数调用合成 一次，并在给定时间过去之后仅被调用一次。
* 去抖和节流是不同的，因为节流虽然中间的处理函数被限制了，但是只是减少了频率，而去抖则把中间的处理函数全部过滤掉了，只执行规判定时间内的最后一个事件。
* 参考：[js的函数抖动和函数节流原理](https://blog.csdn.net/qq_39985511/article/details/82734515)
* 参考：[深入理解JS函数节流和去抖动](https://www.cnblogs.com/goloving/p/8672361.html)

### 什么是事件循环 （eventloop）

* JavaScript的事件分两种，宏任务(macro-task)和微任务(micro-task)
* 宏任务：包括整体代码script，setTimeout，setInterval
* 微任务：Promise.then(非new Promise)，process.nextTick(node中)
* 事件的执行顺序，是先执行宏任务，然后执行微任务，这个是基础，任务可以有同步任务和异步任务，同步的进入主线程，异步的进入Event Table并注册函数，异步事件完成后，会将回调函数放入Event Queue中(宏任务和微任务是不同的Event Queue)，同步任务执行完成后，会从Event Queue中读取事件放入主线程执行，回调函数中可能还会包含不同的任务，因此会循环执行上述操作。
* ![事件循环流程图](https://img-blog.csdn.net/20180506161638888)
* 事件循环的具体步骤
  1. 同步任务直接放入到主线程执行，异步任务（点击事件，定时器，ajax等）挂在后台执行，等待I/O事件完成或行为事件被触发。
  2. 系统后台执行异步任务，如果某个异步任务事件（或者行为事件被触发），则将该任务添加到任务队列的末端，每个任务会对应一个回调函数进行处理。
  3. 执行任务队列中的任务具体是在执行栈中完成的，全部执行完毕后，去读取任务队列中的下一个任务，继续执行，是一个循环的过程，处理一个队列中的任务称之为tick。

### 什么是WebWork -- 多线程技术

* 一个浏览器至少存在三个线程：js引擎线程(处理js)、GUI渲染线程(渲染页面)、浏览器事件触发线程(控制交互)。
* html5的webWorkers提供了js的后台处理线程的API，它允许将复杂耗时的单纯js逻辑处理放在浏览器后台线程中进行处理，让js线程不阻塞UI线程的渲染。这个线程不能和页面进行交互，如获取元素、alert等。多个线程间也是可以通过相同的方法进行数据传递。

### get和post区别

* get参数通过url传递，post放在request body中。
* get请求在url中传递的参数是有长度限制的，而post没有。
* get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。
* get请求的参数只能是ASCII码，所以中文需要URL编码，而post请求传参没有这个限制。
* get请求会浏览器主动cache，而post支持多种编码方式。
* get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。
* GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。
* GET产生一个TCP数据包；POST产生两个TCP数据包。

### 前端常用的性能优化手段

* 包括减少请求数量、减小资源大小、优化网络连接、优化资源加载、减少重绘回流、使用性能更好的API和构建优化
* 请参考： [前端性能优化的七大手段](https://www.cnblogs.com/xiaohuochai/p/9178390.html)

### 浏览器常用的存储方式

* cookie,localStorage和sessionStorage
* 参考：[简单介绍浏览器端的几种存储技术](https://blog.csdn.net/summer_15/article/details/72579533)
  
### 常用的webpack插件有哪些，如何去实现一个插件

* 参考：[探寻 webpack 插件机制](https://www.cnblogs.com/MuYunyun/p/8875908.html)

### webpack实现模块化

### react setState是如何实现的

### 有几千个页面要如何配置路由

### 平时如何解决问题

### 最近在读的一本书
