## HTTP 和 HTTPS 的区别

### 基本概念

HTTP：超文本的传输协议，是互联网应用最为广泛的网络协议；

HTTPS：是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版，即 HTTP 下加入 SSL
层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL；

### 区别

HTTP：http 传输的数据都是未加密的，也就是明文的。

HTTPS：https 协议是由 http 和 ssl 协议构建的可进行
加密传输和身份认证的网络协议，比 http 协议的安全性更高。

### https 加密方式

<https://segmentfault.com/a/1190000019976390>

## url 输入到返回请求的过程

> url 解析 => 查找缓存 => DNS 域名解析 => 建立 TCP 连接 => 发送 http 请求 => 服务器响应返回结果 => 关闭 TCP 连接 => 浏览器渲染

### 浏览器进程

- 用户输入内容，进行 URL 解析（编码）
- 如果是文本，则拼接成默认搜索引擎加关键字的 URL 进行搜索
- 如果是 URL 就进行页面访问请求，并加上协议头（http、https 的区别）

### 网络进程

- 查询缓存（缓存相关知识）
- 如果有浏览器本地缓存可用则使用本地缓存
- DNS 解析（DNS 相关）
- 通过 DNS 来查询 IP 地址
- DNS 先查本地、后查运营商、逐级网上查。（域名解析是从后往前查的）
- 拿到 IP 地址发起 HTTP 请求（这块可以问网络相关各种基础知识，TCP、IP、UDP、HTTPS、HTTP2）
- 建立 TCP 三次握手连接
- 如果是 HTTPS 建立 TLS 安全通道连接（HTTPS 加密方式）
- 发送 HTTP 请求，这个请求可能回到代理服务器或者源服务器。（服务器代理）
- 拿到 HTTP 响应（HTTP 响应码）
- 根据 Content-Type 来判断响应文件类型（常用 HTTP 响应头的作用）
- stream 类，浏览器启动下载界面下载文件。
- text、图片类，浏览器直接展示在页面上
- html 类型，浏览器会进行页面解析。

### 渲染进程

- 页面解析
- 网络进程向渲染进程传输 HTML 数据
- 对 HTML 进行词法分析，通过堆栈算法构建 DOM 树。（AST 语法树）
- 如果遇到外部资源，浏览器会交给网络进程去下载。
- 构建完 DOM 树的同时，将 CSS 代码转为浏览器可以理解的 StyleSheets
- 标准化样式属性值（单位、大小）
- 计算出 DOM 树每个节点的具体样式
- 计算每个 DOM 节点的父节点们的样式（样式继承）
- DOM 树构建完成后， 合并 StyleSheets 构建出 CSSOM 渲染树。
- 排版：遍历渲染树，计算元素的坐标位置。
- 分层：为节点生成图层
- 绘制：用浏览器指令逐条绘制页面元素。（如何避免重绘重排）
- 栅格化
- 合成

## 浏览器事件循环机制（event loop）

<https://juejin.cn/post/6955773607926579214>

### （同步）

js 是单线程语言，只有一个主线程来处理所有的执行任务。当 js 代码被执行的时候，会把不同的变量存储在堆和栈中，其中堆存放的是一些对象，栈存放的是基础变量类型及指针。在遇到方法调用是，会生成一个执行上下文，包括私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的 this 对象。当代码开始允许时，js 会将同步代码按照顺序加入执行栈中依次执行。如果当前执行的是一个方法，js 会向当前执行栈中压入这个方法的执行坏境，并在执行环境中去执行其中的代码。在返回结果后会推出执行坏境并销毁，然后回到上一个方法的执行环境。。这个过程反复进行，直到执行栈中的代码全部执行完毕。

### （异步）

当遇到定时器、后台 ajax 请求这些异步代码时，会挂起继续执行执行栈中的其他任务，当一个异步事件返回结果是，js 会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。 放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码...，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。 (宏任务(定时器)、微任务(Promise)) 在事件队列中根据不用类型的异步而被放入不同的任务队列，当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。

## 强缓存和协商缓存

?

<!-- TODO:  -->

## 跨域

跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对 JavaScript 实施的安全限制。

同源策略： 域名、协议、端口相同。

## 作用域

作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期， 全局作用域 var(不管变量声明是写在哪里，最后都会被提到作用域的顶端)、局部作用域 let

## 变量提升

JavaScript 和其他语言一样，都要经历编译和执行阶段。在这个短暂的编译阶段，JS 引擎会搜集所有的变量声明，并且提前让声明生效。而剩下的语句需要等到执行阶段、等到执行到具体的某一句时才会生效。这就是变量提升背后的机制。其实实质就是一段代码在上下文创建阶段（也就是编译阶段）是能够识别到 var 和 let 创建的变量的，只会对二者的操作不一样：对 var 定义的变量初始化为 undefined，而 let 定义的变量仍然处于未初始化状态。也就是为什么报错是‘’x‘’未初始化的原因

## this 指向

箭头函数的 this 指向为创建箭头函数的外层 this

## 闭包

闭包是指内层函数可以访问到外层函数的作用域，而外层作用域无法访问到内部函数的作用域值 只能通过实现返回函数 访问内部函数作用域值
防抖节流都是比较经典的闭包函数实现场景
闭包的缺点是不利于垃圾回收机制
闭包的优点是希望一个变量长期存储在内存中

## 原型链

我们在使用构造函数创建实例对象时，有一个属性为 prototype，我们可以把方法或者属性挂载到这个属性对象供所有实例对象访问，那这个对象正是调用该构造函数而创建的实例的原型，而每个对象都有*proto*这个属性指向原型，js 中创建一个对象都会关联另一个对象，形成这种链表的形式就叫原型链，最终会指向 null

## 数据类型

string、boolean、null、undefined、NaN、number、symbol、Object

## Promise

状态： pending、reslove、reject
all、allSettled 的区别： all 全部 reslove 才会成功 ；allSettled 不会

## axios 基本实现

## vue3 与 vue2 区别

<!-- ## Proxy (pa ke )

## object.defineProperty () -->

## nextTick 原理？

<!-- 
# 项目

## 来画演示

> 类低代码平台，

- 渲染器 (各种元素)

- 编辑器

- 动画

- 模版数据

- electronJs

- 状态数据流

## 来画设计

- 主题

- 团队协作

- 代码重构

## 抠图宝

- 代码重构

- 旋转

## 虚拟人智能播报

- 作品管理

- 文本编辑 -->
